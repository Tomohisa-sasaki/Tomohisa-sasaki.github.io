<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tomohisa Sasaki Research Profile</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="layout">
    <header class="header">
      <div class="header__search">
        <div class="header__search-field">
          <span class="header__search-icon">
            <span class="header__search-circle"></span>
          </span>
          <span class="header__search-label">AI, economics, muscle</span>
        </div>
      </div>
      <div class="header__meta">
        <div class="header__badge">Research Profile</div>
        <h1 class="header__title">Tomohisa Sasaki</h1>
        <p class="header__subtitle">MIT CSAIL Researcher · AI · Neuroscience · Behavioral Economics</p>
      </div>
    </header>

    <main class="main">
      <section class="grid">
        <article class="card biography-card">
          <h2 class="card__title">Biography</h2>
          <div class="timeline-shell">
            <ul class="timeline">
              <li class="timeline__item">
                <span class="timeline__year">2019-2020</span>
                <div class="timeline__detail">
                  <span class="timeline__highlight">MITES Summer</span>
                  <span class="timeline__sub">Engineering immersion track</span>
                </div>
              </li>
              <li class="timeline__item">
                <span class="timeline__year">2022-20◎    </span>
                <div class="timeline__detail">
                  <span class="timeline__highlight">MIT CSAIL</span>
                  <span class="timeline__sub">Human-AI research residency (Mental Healthcare)</span>
                </div>
              </li>
              <li class="timeline__item">
                <span class="timeline__year">2024-2025</span>
                <div class="timeline__detail">
                  <span class="timeline__highlight">Google Researcher</span>
                  <span class="timeline__sub">AI research internship</span>
                </div>
              </li>
            </ul>
          </div>
        </article>

        <article class="card card--accent research-card" tabindex="0" aria-expanded="false">
          <div class="research-summary">
            <h2 class="card__title">Research Fields</h2>
            <ul class="chip-list">
              <li class="chip">AI Systems Engineering</li>
              <li class="chip">Neuroscience & Mental Health</li>
              <li class="chip">Behavioral Economics</li>
            </ul>
            <p class="card__body">
              He merges adaptive AI interfaces with neural signal analytics to support personal behavior change
              and to unlock more empathetic, human-aware technology ecosystems.
            </p>
          </div>
          <div class="research-visual" aria-hidden="true">
            <div class="visual-flow" role="presentation">
              <div class="visual-toolbar">
                <button type="button" class="visual-tool is-active" data-flow-view="overview">Overview</button>
                <button type="button" class="visual-tool" data-flow-view="deep">Deep Dive</button>
              </div>
              <div class="visual-canvas">
                <div class="visual-node visual-node--capture" data-step="Capture">
                  <span class="visual-node__handle visual-node__handle--left"></span>
                  <span class="visual-node__handle visual-node__handle--right"></span>
                  <header class="visual-node__header">
                    <span>Neural Capture</span>
                  </header>
                  <p class="visual-node__body">
                    Dense EEG, MEG, and fMRI sessions stream raw volumes into a neuro-cloud, tagging each scan with behavioral context.
                  </p>
                  <div class="visual-node__viz visual-node__viz--brain"></div>
                </div>
                <div class="visual-connection visual-connection--capture-processing" aria-hidden="true"></div>
                <div class="visual-node visual-node--processing" data-step="Process">
                  <span class="visual-node__handle visual-node__handle--left"></span>
                  <span class="visual-node__handle visual-node__handle--right"></span>
                  <header class="visual-node__header">
                    <span>Signal Processing</span>
                  </header>
                  <p class="visual-node__body">
                    Adaptive filters, graph spectral decompositions, and spike sorting isolate biomarkers and artifacts in real time.
                  </p>
                  <div class="visual-node__viz visual-node__viz--wave"></div>
                </div>
                <div class="visual-connection visual-connection--processing-visual" aria-hidden="true"></div>
                <div class="visual-node visual-node--visualization" data-step="Visualize">
                  <span class="visual-node__handle visual-node__handle--left"></span>
                  <span class="visual-node__handle visual-node__handle--right"></span>
                  <header class="visual-node__header">
                    <span>Visualization</span>
                  </header>
                  <p class="visual-node__body">
                    Spatiotemporal embeddings render uncertainty cones, region co-activations, and subject-level dashboards.
                  </p>
                  <div class="visual-node__viz visual-node__viz--mesh"></div>
                </div>
                <div class="visual-connection visual-connection--visual-ai" aria-hidden="true"></div>
                <div class="visual-node visual-node--ai" data-step="Infer">
                  <span class="visual-node__handle visual-node__handle--left"></span>
                  <span class="visual-node__handle visual-node__handle--right"></span>
                  <header class="visual-node__header">
                    <span>AI Inference</span>
                  </header>
                  <p class="visual-node__body">
                    Multimodal transformers link neural events to behavioral intent, generating transparent counterfactuals.
                  </p>
                  <div class="visual-node__viz visual-node__viz--network"></div>
                </div>
                <div class="visual-connection visual-connection--ai-behavior" aria-hidden="true"></div>
                <div class="visual-node visual-node--behavior" data-step="Simulate">
                  <span class="visual-node__handle visual-node__handle--left"></span>
                  <span class="visual-node__handle visual-node__handle--right"></span>
                  <header class="visual-node__header">
                    <span>Behavioral Economics</span>
                  </header>
                  <p class="visual-node__body">
                    Agent simulations forecast incentive outcomes and co-design interventions with clinicians.
                  </p>
                  <div class="visual-node__viz visual-node__viz--chart"></div>
                </div>
              </div>
            </div>
          </div>
        </article>
      </section>

      <section class="card card--wide">
        <h2 class="card__title">Current Focus</h2>
        <div class="focus-grid">
          <div class="focus">
            <h3 class="focus__title">Human-Centered AI Design</h3>
            <p class="focus__body">
              Building explainable agent architectures that clarify decision pathways while aligning with nuanced
              user narratives and values.
            </p>
          </div>
          <div class="focus">
            <h3 class="focus__title">Mental Health Support</h3>
            <p class="focus__body">
              Leveraging real-time neural and physiological signals to infer wellness states and trigger meaningful
              interventions in digital therapeutics.
            </p>
          </div>
          <div class="focus">
            <h3 class="focus__title">Behavioral Economics × AI</h3>
            <p class="focus__body">
              Designing incentive-aware algorithms that translate experimental insights into scalable,
              real-world behavioral systems.
            </p>
          </div>
          <div class="focus">
            <h3 class="focus__title">Financial AI Systems</h3>
            <p class="focus__body">
              Architecting self-directed agents that parse financial statements, learn market signals, and deliver
              transparent, auditable recommendations for investment and risk teams.
            </p>
          </div>
        </div>
      </section>

      <section class="card card--wide card--3d">
        <h2 class="card__title">Hobbies & Personal Projects</h2>
        <p class="card__body">
          Outside of the lab, Tomohisa explores embodied intelligence through product prototyping.
          A highlight is a strength training companion app that gamifies progressive overload and recovery insights.
        </p>
        <div class="hobby-module">
          <div class="hobby-block">
            <input type="checkbox" id="hobby-toggle" class="hobby-toggle" aria-controls="hobby-panel">
            <label class="toggle-button" for="hobby-toggle">View App Features</label>
            <div class="hobby-panel" id="hobby-panel" aria-live="polite">
              <article class="feature-card">
                <h3 class="feature-card__title">Adaptive Routines</h3>
                <p class="feature-card__body">
                  Auto-adjusts sets and loads with 3D motion analysis powered by embedded device sensors.
                </p>
              </article>
              <article class="feature-card">
                <h3 class="feature-card__title">Recovery Dashboard</h3>
                <p class="feature-card__body">
                  Surfaces HRV-driven readiness insights and recommends sleep or mobility protocols when needed.
                </p>
              </article>
              <article class="feature-card">
                <h3 class="feature-card__title">Community Challenges</h3>
                <p class="feature-card__body">
                  Hosts cooperative micro-challenges that blend habit loops with supportive social accountability.
                </p>
              </article>
            </div>
          </div>
          <div class="hobby-block">
            <input type="checkbox" id="hobby-preview-toggle" class="hobby-toggle hobby-preview-toggle" aria-controls="hobby-preview">
            <label class="toggle-button toggle-button--ghost" for="hobby-preview-toggle">Launch Interactive Preview</label>
            <div class="hobby-panel hobby-panel--preview" id="hobby-preview">
              <div class="trainer-sim" data-trainer>
                <header class="trainer-sim__header">
                  <div>
                    <h3>Muscle Log Companion</h3>
                    <p>Prototype dashboard mirroring the Flask app: schedule, analytics, and daily session composer.</p>
                  </div>
                  <div class="trainer-sim__period" data-trainer-period></div>
                </header>
                <div class="trainer-sim__layout">
                  <div class="trainer-sim__cols">
                    <section class="trainer-editor" aria-label="Session Composer">
                      <h4>Session Composer</h4>
                      <label class="trainer-label" for="trainer-date">Session date</label>
                      <input class="trainer-input" type="date" id="trainer-date" data-trainer-date>

                    <label class="trainer-label" for="trainer-focus">Focus area</label>
                    <select class="trainer-input" id="trainer-focus" data-trainer-focus>
                      <option value="chest">Chest</option>
                      <option value="shoulders">Shoulders</option>
                      <option value="arms">Arms</option>
                      <option value="legs">Legs</option>
                      <option value="back">Back</option>
                    </select>

                    <label class="trainer-label" for="trainer-movement">Movement</label>
                    <select class="trainer-input" id="trainer-movement" data-trainer-movement></select>

                    <div class="trainer-grid">
                      <label class="trainer-label" for="trainer-sets">Sets</label>
                      <input class="trainer-input" type="number" id="trainer-sets" min="1" max="8" value="3" data-trainer-sets>

                      <label class="trainer-label" for="trainer-reps">Reps</label>
                      <input class="trainer-input" type="number" id="trainer-reps" min="1" max="25" value="8" data-trainer-reps>

                      <label class="trainer-label" for="trainer-weight">Weight (kg)</label>
                      <input class="trainer-input" type="number" id="trainer-weight" min="0" max="400" value="60" data-trainer-weight>
                    </div>

                    <label class="trainer-label" for="trainer-notes">Notes</label>
                    <textarea class="trainer-input trainer-input--textarea" id="trainer-notes" rows="2" placeholder="Tempo, cues, readiness..." data-trainer-notes></textarea>

                    <div class="trainer-actions">
                      <button type="button" class="trainer-btn trainer-btn--primary" data-trainer-add>Add movement</button>
                      <button type="button" class="trainer-btn" data-trainer-save>Commit day</button>
                      <button type="button" class="trainer-btn trainer-btn--ghost" data-trainer-clear>Reset day</button>
                    </div>

                    <div class="trainer-log">
                      <h5>Movements logged</h5>
                      <ul class="trainer-log__list" data-trainer-log></ul>
                      <p class="trainer-log__empty" data-trainer-log-empty>No movements yet. Add one above.</p>
                    </div>
                    </section>

                    <section class="trainer-calendar" aria-label="Training Calendar">
                      <header>
                        <h4>Training Calendar</h4>
                        <div class="trainer-calendar__controls">
                          <button type="button" data-trainer-month="prev" aria-label="Previous month">‹</button>
                          <span data-trainer-calendar-title></span>
                          <button type="button" data-trainer-month="next" aria-label="Next month">›</button>
                        </div>
                      </header>
                      <div class="trainer-calendar__grid" data-trainer-calendar></div>
                      <div class="trainer-tags">
                        <span data-tag="chest">Chest</span><span data-tag="shoulders">Shoulders</span><span data-tag="arms">Arms</span><span data-tag="legs">Legs</span><span data-tag="back">Back</span>
                      </div>
                    </section>
                  </div>

                  <section class="trainer-analytics" aria-label="Analytics">
                    <header class="trainer-analytics__header">
                      <div class="trainer-analytics__title">
                        <h4>Training Insights</h4>
                        <span data-trainer-trend-subtitle>All movements · Volume</span>
                      </div>
                      <div class="trainer-analytics__filters">
                        <select class="trainer-input trainer-input--compact" data-trainer-filter-movement>
                          <option value="all">All Movements</option>
                        </select>
                        <select class="trainer-input trainer-input--compact" data-trainer-filter-metric>
                          <option value="volume">Volume (sets×reps×weight)</option>
                          <option value="reps">Total reps</option>
                          <option value="weight">Average weight</option>
                        </select>
                      </div>
                    </header>
                    <div class="trainer-chart" data-trainer-chart></div>
                    <div class="trainer-summary">
                      <div>
                        <span>Total Sets</span>
                        <strong data-trainer-total-sets>0</strong>
                      </div>
                      <div>
                        <span>Total Load</span>
                        <strong data-trainer-total-load>0 kg</strong>
                      </div>
                      <div>
                        <span>Focus Mix</span>
                        <strong data-trainer-focus-mix>—</strong>
                      </div>
                    </div>
                    <footer data-trainer-status data-tone="neutral">Session idle</footer>
                  </section>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="card card--wide">
        <h2 class="card__title">Contact</h2>
        <form class="contact-form" action="#" method="post">
          <label class="form-label" for="email">Email</label>
          <input class="form-input" id="email" name="email" type="email" placeholder="you@example.com" required>

          <label class="form-label" for="message">Message</label>
          <textarea class="form-input form-input--textarea" id="message" name="message" placeholder="Share how we can collaborate..." required></textarea>

          <button class="form-submit" type="submit">Send Message</button>
        </form>
      </section>
    </main>

    <footer class="footer">
      <p>© Tomohisa Sasaki</p>
    </footer>
  </div>
  <script>
    (function () {
      if (!window.matchMedia("(pointer: fine)").matches) {
        return;
      }

      const body = document.body;
      body.classList.add("has-custom-cursor");

      const cursorDot = document.createElement("div");
      const cursorRing = document.createElement("div");
      cursorDot.className = "cursor-dot";
      cursorRing.className = "cursor-ring";
      body.append(cursorRing, cursorDot);

      const setPosition = (x, y) => {
        const posX = `${x}px`;
        const posY = `${y}px`;
        cursorDot.style.setProperty("--cursor-x", posX);
        cursorDot.style.setProperty("--cursor-y", posY);
        cursorRing.style.setProperty("--cursor-x", posX);
        cursorRing.style.setProperty("--cursor-y", posY);
      };

      let latestX = window.innerWidth / 2;
      let latestY = window.innerHeight / 2;
      setPosition(latestX, latestY);

      document.addEventListener("pointermove", (event) => {
        latestX = event.clientX;
        latestY = event.clientY;
        requestAnimationFrame(() => setPosition(latestX, latestY));
      }, { passive: true });

      document.addEventListener("pointerdown", () => {
        cursorRing.classList.add("cursor-ring--click");
      });

      document.addEventListener("pointerup", () => {
        cursorRing.classList.remove("cursor-ring--click");
      });

      const interactiveSelector = "a, button, input, textarea, select, .toggle-button, .feature-card, .card";
      document.addEventListener("pointerover", (event) => {
        if (event.target.closest(interactiveSelector)) {
          cursorRing.classList.add("cursor-ring--active");
        }
      });

      document.addEventListener("pointerout", (event) => {
        if (
          event.target.closest(interactiveSelector) &&
          (!event.relatedTarget || !event.relatedTarget.closest(interactiveSelector))
        ) {
          cursorRing.classList.remove("cursor-ring--active");
        }
      });
    })();

    (function () {
      const layout = document.querySelector(".layout");
      const researchCard = document.querySelector(".research-card");
      if (!layout || !researchCard) {
        return;
      }

      const activate = () => {
        layout.classList.add("research-active");
        researchCard.setAttribute("aria-expanded", "true");
      };
      const deactivate = () => {
        layout.classList.remove("research-active");
        researchCard.setAttribute("aria-expanded", "false");
      };

      const supportsHover = window.matchMedia("(hover: hover)").matches;

      if (supportsHover) {
        researchCard.addEventListener("mouseenter", activate);
        researchCard.addEventListener("mouseleave", deactivate);
      }

      researchCard.addEventListener("focusin", activate);
      researchCard.addEventListener("focusout", (event) => {
        if (!researchCard.contains(event.relatedTarget)) {
          deactivate();
        }
      });

      if (!supportsHover) {
        researchCard.addEventListener("click", () => {
          if (layout.classList.contains("research-active")) {
            deactivate();
          } else {
            activate();
          }
        });
      }

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          deactivate();
        }
      });

      const visualFlow = researchCard.querySelector(".visual-flow");
      const flowButtons = researchCard.querySelectorAll(".visual-tool");
      if (visualFlow && flowButtons.length) {
        visualFlow.dataset.view = "overview";
        flowButtons.forEach((button) => {
          button.addEventListener("click", () => {
            flowButtons.forEach((btn) => btn.classList.remove("is-active"));
            button.classList.add("is-active");
            visualFlow.dataset.view = button.dataset.flowView || "overview";
          });
        });
      }
    })();

    (function () {
      const trainer = document.querySelector("[data-trainer]");
      if (!trainer) {
        return;
      }

      const focusLabels = {
        chest: "Chest",
        shoulders: "Shoulders",
        arms: "Arms",
        legs: "Legs",
        back: "Back"
      };

      const focusBadges = {
        chest: "CH",
        shoulders: "SH",
        arms: "AR",
        legs: "LG",
        back: "BK"
      };

      const movementLibrary = {
        chest: ["Flat Bench Press", "Incline Dumbbell Press", "Cable Fly", "Push-Up Variations"],
        shoulders: ["Seated Dumbbell Press", "Lateral Raise", "Rear Delt Fly", "Face Pull"],
        arms: ["Barbell Curl", "Hammer Curl", "Triceps Dip", "Skull Crusher"],
        legs: ["Back Squat", "Romanian Deadlift", "Bulgarian Split Squat", "Leg Press"],
        back: ["Deadlift", "Bent-Over Row", "Lat Pulldown", "Single-Arm Row"]
      };

      const metricLabels = {
        volume: "Volume (sets×reps×weight)",
        reps: "Total reps",
        weight: "Average weight"
      };

      const today = new Date();
      const todayISO = formatISO(today);

      const dateInput = trainer.querySelector("[data-trainer-date]");
      const focusSelect = trainer.querySelector("[data-trainer-focus]");
      const movementSelect = trainer.querySelector("[data-trainer-movement]");
      const setsInput = trainer.querySelector("[data-trainer-sets]");
      const repsInput = trainer.querySelector("[data-trainer-reps]");
      const weightInput = trainer.querySelector("[data-trainer-weight]");
      const notesInput = trainer.querySelector("[data-trainer-notes]");
      const addButton = trainer.querySelector("[data-trainer-add]");
      const saveButton = trainer.querySelector("[data-trainer-save]");
      const clearButton = trainer.querySelector("[data-trainer-clear]");
      const logList = trainer.querySelector("[data-trainer-log]");
      const logEmpty = trainer.querySelector("[data-trainer-log-empty]");
      const calendarGrid = trainer.querySelector("[data-trainer-calendar]");
      const calendarTitle = trainer.querySelector("[data-trainer-calendar-title]");
      const periodEl = trainer.querySelector("[data-trainer-period]");
      const filterMovementSelect = trainer.querySelector("[data-trainer-filter-movement]");
      const filterMetricSelect = trainer.querySelector("[data-trainer-filter-metric]");
      const chartContainer = trainer.querySelector("[data-trainer-chart]");
      const trendSubtitleEl = trainer.querySelector("[data-trainer-trend-subtitle]");
      const totalSetsEl = trainer.querySelector("[data-trainer-total-sets]");
      const totalLoadEl = trainer.querySelector("[data-trainer-total-load]");
      const focusMixEl = trainer.querySelector("[data-trainer-focus-mix]");
      const statusEl = trainer.querySelector("[data-trainer-status]");
      const monthButtons = trainer.querySelectorAll("[data-trainer-month]");

      let statusTimeout = null;

      const state = {
        entries: new Map(),
        draft: [],
        selectedDate: todayISO,
        monthCursor: new Date(today.getFullYear(), today.getMonth(), 1)
      };

      function formatISO(date) {
        return date.toISOString().slice(0, 10);
      }

      function parseISO(iso) {
        const [year, month, day] = iso.split("-").map(Number);
        return new Date(year, month - 1, day);
      }

      function setStatus(message, tone = "neutral") {
        if (!statusEl) {
          return;
        }
        statusEl.textContent = message;
        statusEl.setAttribute("data-tone", tone);
        if (statusTimeout) {
          clearTimeout(statusTimeout);
        }
        statusTimeout = window.setTimeout(() => {
          statusEl.textContent = "Session idle";
          statusEl.setAttribute("data-tone", "neutral");
        }, 3200);
      }

      function setMovementOptions(focus) {
        const movements = movementLibrary[focus] || [];
        movementSelect.innerHTML = "";
        movements.forEach((movement, index) => {
          const option = document.createElement("option");
          option.value = movement;
          option.textContent = movement;
          if (index === 0) {
            option.selected = true;
          }
          movementSelect.append(option);
        });
      }

      function getSavedEntriesFor(dateISO) {
        return state.entries.get(dateISO) || [];
      }

      function getAllSavedEntries() {
        const collection = [];
        state.entries.forEach((entries, iso) => {
          entries.forEach((entry) => {
            collection.push({ iso, ...entry });
          });
        });
        return collection;
      }

      function populateMovementFilter() {
        const previous = filterMovementSelect.value || "all";
        const movements = new Set();
        getAllSavedEntries().forEach((entry) => {
          movements.add(entry.movement);
        });
        const sortedMovements = Array.from(movements).sort((a, b) => a.localeCompare(b));

        filterMovementSelect.innerHTML = "";

        const allOption = document.createElement("option");
        allOption.value = "all";
        allOption.textContent = "All Movements";
        filterMovementSelect.append(allOption);

        sortedMovements.forEach((movement) => {
          const option = document.createElement("option");
          option.value = movement;
          option.textContent = movement;
          filterMovementSelect.append(option);
        });

        if (previous !== "all" && !movements.has(previous)) {
          filterMovementSelect.value = "all";
        } else {
          filterMovementSelect.value = previous;
        }
      }

      function renderLog() {
        logList.innerHTML = "";
        const saved = getSavedEntriesFor(state.selectedDate);
        const pending = state.draft;
        if (!saved.length && !pending.length) {
          logEmpty.hidden = false;
          return;
        }

        logEmpty.hidden = true;
        const fragment = document.createDocumentFragment();

        const appendEntry = (entry, statusLabel) => {
          const item = document.createElement("li");
          item.className = "trainer-log__item";
          item.innerHTML = `
            <div class="trainer-log__meta">
              <span>${statusLabel}</span>
              <span>${focusLabels[entry.focus]}</span>
              <span>${entry.sets}×${entry.reps} @ ${entry.weight}kg</span>
            </div>
            <p class="trainer-log__title">${entry.movement}</p>
            <p class="trainer-log__notes">${entry.notes ? entry.notes : "No notes provided."}</p>
          `;
          fragment.append(item);
        };

        saved.forEach((entry) => appendEntry(entry, "Saved"));
        pending.forEach((entry) => appendEntry(entry, "Pending"));

        logList.append(fragment);
      }

      function renderCalendar() {
        calendarGrid.innerHTML = "";
        const year = state.monthCursor.getFullYear();
        const month = state.monthCursor.getMonth();
        const firstOfMonth = new Date(year, month, 1);
        const startingDay = firstOfMonth.getDay();
        const startDate = new Date(year, month, 1 - startingDay);
        const totalCells = 42;

        const formatter = new Intl.DateTimeFormat("en-US", { month: "long", year: "numeric" });
        calendarTitle.textContent = formatter.format(firstOfMonth);

        for (let i = 0; i < totalCells; i++) {
          const current = new Date(startDate);
          current.setDate(startDate.getDate() + i);
          const iso = formatISO(current);
          const dayButton = document.createElement("button");
          dayButton.type = "button";
          dayButton.className = "trainer-day";
          dayButton.textContent = current.getDate().toString();

          if (current.getMonth() !== month) {
            dayButton.classList.add("is-other");
          }

          if (iso === todayISO) {
            dayButton.classList.add("is-today");
          }

          const saved = getSavedEntriesFor(iso);
          if (saved.length) {
            dayButton.dataset.hasSession = "true";
            const focusCount = saved.reduce((acc, entry) => {
              acc[entry.focus] = (acc[entry.focus] || 0) + 1;
              return acc;
            }, {});
            const dominantFocus = Object.entries(focusCount).sort((a, b) => b[1] - a[1])[0][0];
            dayButton.dataset.focus = dominantFocus;

            const badge = document.createElement("span");
            badge.className = "trainer-day__badge";
            badge.textContent = focusBadges[dominantFocus] || focusLabels[dominantFocus].slice(0, 2).toUpperCase();
            dayButton.title = `Focus: ${focusLabels[dominantFocus]}`;
            dayButton.append(badge);
          }

          if (iso === state.selectedDate) {
            dayButton.classList.add("is-selected");
          }

          dayButton.addEventListener("click", () => {
            state.selectedDate = iso;
            state.draft = [];
            dateInput.value = iso;
            const selectedDate = parseISO(iso);
            state.monthCursor = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
            setStatus(`Loaded ${iso}`, "neutral");
            renderAll();
          });

          calendarGrid.append(dayButton);
        }
      }

      function renderChart() {
        if (!chartContainer) {
          return;
        }
        chartContainer.innerHTML = "";

        const metric = filterMetricSelect.value || "volume";
        const selectedMovement = filterMovementSelect.value || "all";
        const dataset = Array.from(state.entries.entries())
          .map(([iso, entries]) => {
            const filtered = selectedMovement === "all" ? entries : entries.filter((entry) => entry.movement === selectedMovement);
            if (!filtered.length) {
              return null;
            }
            const value = (() => {
              if (metric === "volume") {
                return filtered.reduce((total, entry) => total + entry.sets * entry.reps * entry.weight, 0);
              }
              if (metric === "reps") {
                return filtered.reduce((total, entry) => total + entry.sets * entry.reps, 0);
              }
              const weighted = filtered.filter((entry) => entry.weight > 0);
              if (!weighted.length) {
                return 0;
              }
              const totalWeight = weighted.reduce((total, entry) => total + entry.weight, 0);
              return totalWeight / weighted.length;
            })();
            const label = new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(parseISO(iso));
            return { iso, value, label };
          })
          .filter(Boolean)
          .sort((a, b) => (a.iso > b.iso ? 1 : -1));

        const movementLabel = selectedMovement === "all" ? "All movements" : selectedMovement;
        trendSubtitleEl.textContent = `${movementLabel} · ${metricLabels[metric]}`;

        if (!dataset.length) {
          const empty = document.createElement("p");
          empty.className = "trainer-chart__empty";
          empty.textContent = "No saved sessions match this filter yet.";
          chartContainer.append(empty);
          return;
        }

        const svgNS = "http://www.w3.org/2000/svg";
        const svgHeight = 160;
        const widthPerPoint = 80;
        const svgWidth = Math.max((dataset.length - 1) * widthPerPoint, 240);
        const minValue = Math.min(...dataset.map((d) => d.value));
        const maxValue = Math.max(...dataset.map((d) => d.value));
        const range = maxValue - minValue || 1;

        const singlePoint = dataset.length === 1;
        const points = dataset.map((point, index) => {
          const x = singlePoint ? svgWidth / 2 : index * widthPerPoint;
          const normalized = singlePoint ? 0.5 : (point.value - minValue) / range;
          const y = svgHeight - normalized * (svgHeight - 40) - 10;
          return { x, y, label: point.label, iso: point.iso, value: point.value };
        });

        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
        svg.setAttribute("preserveAspectRatio", "none");
        svg.setAttribute("width", String(svgWidth));
        svg.setAttribute("height", String(svgHeight));

        const axis = document.createElementNS(svgNS, "line");
        axis.setAttribute("x1", "0");
        axis.setAttribute("y1", String(svgHeight - 20));
        axis.setAttribute("x2", String(svgWidth));
        axis.setAttribute("y2", String(svgHeight - 20));
        axis.setAttribute("stroke", "rgba(95, 227, 176, 0.18)");
        axis.setAttribute("stroke-width", "2");
        svg.append(axis);

        const path = document.createElementNS(svgNS, "path");
        const d = points
          .map((point, index) => `${index === 0 ? "M" : "L"} ${point.x} ${point.y}`)
          .join(" ");
        path.setAttribute("d", d);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "rgba(149, 227, 176, 0.8)");
        path.setAttribute("stroke-width", "3");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        svg.append(path);

        points.forEach((point) => {
          const circle = document.createElementNS(svgNS, "circle");
          circle.setAttribute("cx", String(point.x));
          circle.setAttribute("cy", String(point.y));
          circle.setAttribute("r", "5");
          circle.setAttribute("fill", "rgba(46, 204, 113, 0.9)");

          const title = document.createElementNS(svgNS, "title");
          const formattedValue = metric === "weight" ? point.value.toFixed(1) : Math.round(point.value);
          title.textContent = `${point.label}: ${formattedValue}`;
          circle.append(title);

          svg.append(circle);

          const text = document.createElementNS(svgNS, "text");
          text.setAttribute("x", String(point.x));
          text.setAttribute("y", String(svgHeight - 6));
          text.setAttribute("font-size", "10");
          text.setAttribute("fill", "rgba(176, 220, 198, 0.7)");
          text.setAttribute("text-anchor", "middle");
          text.textContent = point.label;
          svg.append(text);
        });

        chartContainer.append(svg);
      }

      function renderSummary() {
        let totalSets = 0;
        let totalLoad = 0;
        const focusCounter = {};
        state.entries.forEach((entries) => {
          entries.forEach((entry) => {
            totalSets += entry.sets;
            totalLoad += entry.sets * entry.reps * entry.weight;
            focusCounter[entry.focus] = (focusCounter[entry.focus] || 0) + 1;
          });
        });
        totalSetsEl.textContent = totalSets;
        totalLoadEl.textContent = `${Math.round(totalLoad)} kg`;
        if (Object.keys(focusCounter).length === 0) {
          focusMixEl.textContent = "—";
        } else {
          const mix = Object.entries(focusCounter)
            .sort((a, b) => b[1] - a[1])
            .map(([focus, count]) => `${focusLabels[focus]} (${count})`)
            .join(" · ");
          focusMixEl.textContent = mix;
        }
      }

      function renderPeriod() {
        const selected = parseISO(state.selectedDate);
        const start = new Date(selected);
        const day = selected.getDay();
        const diffToMonday = (day + 6) % 7;
        start.setDate(selected.getDate() - diffToMonday);
        const end = new Date(start);
        end.setDate(start.getDate() + 6);
        const formatter = new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" });
        periodEl.textContent = `Week of ${formatter.format(start)} – ${formatter.format(end)}`;
      }

      function renderAll() {
        renderLog();
        renderCalendar();
        populateMovementFilter();
        renderChart();
        renderSummary();
        renderPeriod();
      }

      function addEntry() {
        const date = state.selectedDate;
        const focus = focusSelect.value;
        const movement = movementSelect.value;
        const sets = Number.parseInt(setsInput.value, 10);
        const reps = Number.parseInt(repsInput.value, 10);
        const weight = Number.parseFloat(weightInput.value);
        const notes = notesInput.value.trim();

        if (!movement) {
          setStatus("Select a movement to log.", "warn");
          return;
        }

        state.draft.push({
          date,
          focus,
          movement,
          sets: Number.isFinite(sets) ? sets : 1,
          reps: Number.isFinite(reps) ? reps : 1,
          weight: Number.isFinite(weight) ? weight : 0,
          notes
        });
        notesInput.value = "";
        setStatus(`Added ${movement} to ${date}.`, "success");
        renderLog();
      }

      function commitDay() {
        if (state.draft.length === 0) {
          setStatus("Add at least one movement before committing.", "warn");
          return;
        }
        const current = getSavedEntriesFor(state.selectedDate);
        state.entries.set(state.selectedDate, [...current, ...state.draft]);
        state.draft = [];
        setStatus(`Session committed for ${state.selectedDate}.`, "success");
        renderAll();
      }

      function clearComposer() {
        state.draft = [];
        notesInput.value = "";
        setStatus("Composer reset.", "neutral");
        setMovementOptions(focusSelect.value);
        setsInput.value = "3";
        repsInput.value = "8";
        weightInput.value = "60";
        renderLog();
      }

      function shiftMonth(direction) {
        const delta = direction === "next" ? 1 : -1;
        state.monthCursor.setMonth(state.monthCursor.getMonth() + delta);
        renderCalendar();
      }

      dateInput.value = todayISO;

      dateInput.addEventListener("change", () => {
        const next = dateInput.value || todayISO;
        state.selectedDate = next;
        state.draft = [];
        const dateObj = parseISO(next);
        state.monthCursor = new Date(dateObj.getFullYear(), dateObj.getMonth(), 1);
        setStatus(`Loaded ${next}.`, "neutral");
        renderAll();
      });

      focusSelect.addEventListener("change", () => {
        setMovementOptions(focusSelect.value);
      });

      addButton.addEventListener("click", addEntry);
      saveButton.addEventListener("click", commitDay);
      clearButton.addEventListener("click", clearComposer);

      monthButtons.forEach((button) => {
        button.addEventListener("click", () => shiftMonth(button.dataset.trainerMonth));
      });

      filterMovementSelect.addEventListener("change", renderChart);
      filterMetricSelect.addEventListener("change", renderChart);

      setMovementOptions(focusSelect.value);
      filterMovementSelect.value = "all";
      filterMetricSelect.value = "volume";
      renderAll();
    })();
  </script>
</body>
</html>
