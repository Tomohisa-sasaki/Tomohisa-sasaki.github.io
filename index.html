<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tomohisa Sasaki | Profile</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="bg-swirl" aria-hidden="true">
    <div class="bg-swirl__ring bg-swirl__ring--one"></div>
    <div class="bg-swirl__ring bg-swirl__ring--two"></div>
    <div class="bg-swirl__gradient"></div>
  </div>

  <div class="page">
    <aside class="profile-panel" aria-label="プロフィールとメニュー">
      <div class="profile-card" data-motion>
        <span class="profile-card__glow" aria-hidden="true"></span>
        <div class="profile-card__status">
          <span class="profile-card__pill profile-card__pill--live">Live</span>
          <span class="profile-card__pill profile-card__pill--role">CSAIL</span>
        </div>
        <figure class="profile-card__avatar">
          <img src="image.png" alt="Tomohisa Sasaki" loading="lazy">
        </figure>
        <div class="profile-card__meta">
          <p class="profile-card__label">Human-AI Researcher</p>
          <h1 class="profile-card__name">Tomohisa Sasaki</h1>
          <div class="profile-card__tags">
            <span>#AI</span>
            <span>#Finance</span>
            <span>#Healthcare</span>
          </div>
          <p class="profile-card__annotation">Neuro-adaptive systems / Behavioral economics / Embodied intelligence</p>
        </div>
        <div class="profile-card__metrics">
          <div>
            <span class="profile-card__metric-label">研究協業</span>
            <strong>24+</strong>
          </div>
          <div>
            <span class="profile-card__metric-label">プロトタイプ</span>
            <strong>12</strong>
          </div>
          <div>
            <span class="profile-card__metric-label">Mentorship</span>
            <strong>18</strong>
          </div>
        </div>
        <a class="profile-card__cta" href="#contact">コラボ依頼</a>
      </div>
      <nav class="profile-nav" aria-label="セクションメニュー">
        <button class="profile-nav__item is-active" data-nav-target="#bio">略歴</button>
        <button class="profile-nav__item" data-nav-target="#research">研究内容</button>
        <button class="profile-nav__item" data-nav-target="#products">プロダクト紹介</button>
        <button class="profile-nav__item" data-nav-target="#contact">コンタクト</button>
      </nav>
      <a class="embed-card embed-card--linkedin" href="https://www.linkedin.com/in/tomohisa-sasaki" target="_blank" rel="noreferrer">
        <div class="embed-card__icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
            <path d="M4.98 3.5C4.98 4.88 3.88 6 2.5 6S0 4.88 0 3.5 1.12 1 2.5 1s2.48 1.12 2.48 2.5zM.5 8h4V24h-4V8zm7.5 0h3.8v2.2h.05c.53-1 1.82-2.2 3.74-2.2 4 0 4.74 2.6 4.74 5.9V24h-4v-7.6c0-1.8-.03-4.1-2.5-4.1-2.5 0-2.9 1.9-2.9 4v7.7h-4V8z"></path>
          </svg>
        </div>
        <div class="embed-card__body">
          <p class="embed-card__label">LinkedIn</p>
          <p class="embed-card__title">tomohisa-ai</p>
          <p class="embed-card__meta">AI × Finance の最新アップデートを配信中</p>
        </div>
        <span class="embed-card__status">Follow</span>
      </a>
      <a class="floating-cta" href="#research">最新の研究をみる</a>
    </aside>

    <main class="content">
      <section id="bio" class="section" data-motion>
        <header class="section__header">
          <p class="section__eyebrow">Career Timeline</p>
          <h2 class="section__title">略歴</h2>
          <p class="section__lead">MIT での出発から Google AI での挑戦まで、流れるようなキャリアを下から上へトレースします。</p>
        </header>
        <div class="timeline" role="list">
          <article class="timeline__item" role="listitem">
            <div class="timeline__year">2019</div>
            <div class="timeline__body">
              <h3>MITES Summer Program @ MIT</h3>
              <p>工学没入型トラックで、行動科学と機械学習を横断する初期の探究を開始。</p>
            </div>
          </article>
          <article class="timeline__item" role="listitem">
            <div class="timeline__year">2022</div>
            <div class="timeline__body">
              <h3>MIT Research Assistant</h3>
              <p>CSAIL でヒューマンセンタード AI を研究。メンタルヘルス×AI の実装指針を策定。</p>
            </div>
          </article>
          <article class="timeline__item" role="listitem">
            <div class="timeline__year">2024</div>
            <div class="timeline__body">
              <h3>Google AI Researcher</h3>
              <p>AI とファイナンスの交差領域で、説明可能なエージェントをリードし、臨床現場とも連携。</p>
            </div>
          </article>
        </div>
      </section>

      <section id="research" class="section" data-motion>
        <header class="section__header">
          <p class="section__eyebrow">AI × Healthcare</p>
          <h2 class="section__title">研究内容</h2>
        </header>
        <div class="research-grid">
          <div class="research-grid__text">
            <p>
              AI とヘルスケアの境界で、脳波・fMRI・デジタルバイオマーカーを解析できるハイブリッド AI を構築。
              パーソナルなニューロデータを高速に理解し、臨床意思決定を支援するプロトコルを開発しています。
            </p>
            <ul>
              <li>脳活動の多解像度解析とアテンションマップのインタラクティブ可視化</li>
              <li>行動経済モデルを組み込んだ介入シミュレータ</li>
              <li>医療従事者向けの説明可能なダッシュボード</li>
            </ul>
          </div>
          <div class="research-grid__visual" aria-hidden="true">
            <div class="research-orb">
              <span class="research-orb__pulse"></span>
              <span class="research-orb__node research-orb__node--one"></span>
              <span class="research-orb__node research-orb__node--two"></span>
              <span class="research-orb__node research-orb__node--three"></span>
            </div>
            <p class="research-grid__caption">Neuro-pattern decoding pipeline</p>
          </div>
        </div>
        <div class="research-panels">
          <article class="research-panel">
            <div class="research-panel__icon" aria-hidden="true">01</div>
            <h3>Neural capture</h3>
            <p>高密度 EEG/MEG から行動コンテキストを抽出し、パーソナライズされた特徴空間を構築。</p>
          </article>
          <article class="research-panel">
            <div class="research-panel__icon" aria-hidden="true">02</div>
            <h3>Adaptive inference</h3>
            <p>グラフ Transformer を使い、脳活動とバイタルの多変量シグナルをリアルタイム推論。</p>
          </article>
          <article class="research-panel">
            <div class="research-panel__icon" aria-hidden="true">03</div>
            <h3>Clinical UX</h3>
            <p>説明可能なストーリーカードで医師と患者をつなぎ、介入の意思決定を可視化。</p>
          </article>
        </div>
      </section>

      <section id="products" class="section" data-motion>
        <header class="section__header">
          <p class="section__eyebrow">Product Stories</p>
          <h2 class="section__title">プロダクト紹介</h2>
          <p class="section__lead">Finance × AI の意思決定ツールと、筋肉ログのフルスタックプロトタイプをまず紹介します。</p>
        </header>
        <div class="product-chips" role="list">
          <span class="product-chip product-chip--finance" role="listitem">Finance Intelligence</span>
          <span class="product-chip product-chip--health" role="listitem">Healthcare</span>
          <span class="product-chip product-chip--muscle" role="listitem">Muscle Log</span>
        </div>
        <div class="product-grid">
          <article class="product-card product-card--finance">
            <div class="product-card__header">
              <p class="product-card__eyebrow">Finance Signal Lab</p>
              <h3>Alpha Canvas</h3>
            </div>
            <p class="product-card__body">
              上場企業の決算テキスト・ESG 指標・マクロシグナルをクロス解析し、リスクと機会をパステルな可視化で提示するリーンプロダクト。
            </p>
            <ul class="product-card__list">
              <li>自然言語グラフ × 財務ファンダメンタルのペアリング</li>
              <li>リスク・α・インパクト指標を並列比較</li>
              <li>AI レコメンドと人間の説明責任を両立</li>
            </ul>
          </article>

          <article class="product-card product-card--muscle">
            <div class="product-card__header">
              <p class="product-card__eyebrow">Embodied Intelligence</p>
              <h3>Muscle Log Companion</h3>
            </div>
            <p class="product-card__body">
              ファイルにもある Flask プロトタイプをブラッシュアップし、筋トレセッションをマルチデバイスで記録できるトレーナーアプリ UI を再現。
            </p>
            <div class="trainer-wrapper">
              <div class="trainer-sim" data-trainer>
                <header class="trainer-sim__header">
                  <div>
                    <p class="trainer-sim__eyebrow">Session builder</p>
                    <h4>Weekly progressive plan</h4>
                  </div>
                  <div class="trainer-sim__period" data-trainer-period></div>
                </header>
                <div class="trainer-sim__layout">
                  <section class="trainer-editor" aria-label="セッション作成">
                    <label class="trainer-label" for="trainer-date">日付</label>
                    <input class="trainer-input" type="date" id="trainer-date" data-trainer-date>

                    <label class="trainer-label" for="trainer-focus">フォーカス部位</label>
                    <select class="trainer-input" id="trainer-focus" data-trainer-focus>
                      <option value="chest">Chest</option>
                      <option value="shoulders">Shoulders</option>
                      <option value="arms">Arms</option>
                      <option value="legs">Legs</option>
                      <option value="back">Back</option>
                    </select>

                    <label class="trainer-label" for="trainer-movement">ムーブメント</label>
                    <select class="trainer-input" id="trainer-movement" data-trainer-movement></select>

                    <div class="trainer-grid">
                      <div>
                        <label class="trainer-label" for="trainer-sets">セット</label>
                        <input class="trainer-input" type="number" id="trainer-sets" min="1" max="8" value="3" data-trainer-sets>
                      </div>
                      <div>
                        <label class="trainer-label" for="trainer-reps">レップ</label>
                        <input class="trainer-input" type="number" id="trainer-reps" min="1" max="25" value="8" data-trainer-reps>
                      </div>
                      <div>
                        <label class="trainer-label" for="trainer-weight">重量 (kg)</label>
                        <input class="trainer-input" type="number" id="trainer-weight" min="0" max="400" value="60" data-trainer-weight>
                      </div>
                    </div>

                    <label class="trainer-label" for="trainer-notes">メモ</label>
                    <textarea class="trainer-input trainer-input--textarea" id="trainer-notes" rows="2" data-trainer-notes placeholder="Tempo, cues, readiness..."></textarea>

                    <div class="trainer-actions">
                      <button type="button" class="trainer-btn trainer-btn--primary" data-trainer-add>追加</button>
                      <button type="button" class="trainer-btn" data-trainer-save>記録</button>
                      <button type="button" class="trainer-btn trainer-btn--ghost" data-trainer-clear>クリア</button>
                    </div>

                    <div class="trainer-log">
                      <h5>ログ</h5>
                      <ul class="trainer-log__list" data-trainer-log></ul>
                      <p class="trainer-log__empty" data-trainer-log-empty>まだムーブメントがありません。</p>
                    </div>
                  </section>

                  <section class="trainer-calendar" aria-label="トレーニングカレンダー">
                    <header>
                      <div class="trainer-calendar__controls">
                        <button type="button" data-trainer-month="prev" aria-label="先月">‹</button>
                        <span data-trainer-calendar-title></span>
                        <button type="button" data-trainer-month="next" aria-label="翌月">›</button>
                      </div>
                    </header>
                    <div class="trainer-calendar__grid" data-trainer-calendar></div>
                    <div class="trainer-tags">
                      <span data-tag="chest">Chest</span>
                      <span data-tag="shoulders">Shoulders</span>
                      <span data-tag="arms">Arms</span>
                      <span data-tag="legs">Legs</span>
                      <span data-tag="back">Back</span>
                    </div>
                  </section>

                  <section class="trainer-analytics" aria-label="アナリティクス">
                    <header class="trainer-analytics__header">
                      <div>
                        <h5>トレンド</h5>
                        <span data-trainer-trend-subtitle>Volume vs. Quality</span>
                      </div>
                      <div class="trainer-analytics__filters">
                        <select class="trainer-input trainer-input--compact" data-trainer-filter-movement>
                          <option value="all">All Movements</option>
                        </select>
                        <select class="trainer-input trainer-input--compact" data-trainer-filter-metric>
                          <option value="volume">Volume</option>
                          <option value="reps">Reps</option>
                          <option value="weight">Weight</option>
                        </select>
                      </div>
                    </header>
                    <div class="trainer-chart" data-trainer-chart></div>
                    <div class="trainer-summary">
                      <div>Sets <strong data-trainer-total-sets>0</strong></div>
                      <div>Total load <strong data-trainer-total-load>0 kg</strong></div>
                      <div>Focus mix <strong data-trainer-focus-mix>—</strong></div>
                    </div>
                    <footer class="trainer-status" data-trainer-status data-tone="neutral">Session idle</footer>
                  </section>
                </div>
              </div>
            </div>
          </article>
        </div>
      </section>

      <section id="contact" class="section" data-motion>
        <header class="section__header">
          <p class="section__eyebrow">Let&apos;s Build Together</p>
          <h2 class="section__title">コンタクト</h2>
          <p class="section__lead">メッセージを残していただければ、AI×Finance/Healthcare の次の実験について一緒に議論できます。</p>
        </header>
        <div class="contact-grid">
          <article class="contact-highlight">
            <p class="contact-highlight__eyebrow">Response within 48h</p>
            <h3>AI×Financeの問いをお待ちしています</h3>
            <ul>
              <li>ヘルスケア連携 / 臨床研究の共創</li>
              <li>ファイナンス × 生成 AI の R&amp;D</li>
              <li>筋トレアプリやウェアラブルの実装相談</li>
            </ul>
            <div class="contact-highlight__avatars" aria-label="Recent collaborators">
              <span aria-hidden="true"></span>
              <span aria-hidden="true"></span>
              <span aria-hidden="true"></span>
            </div>
          </article>
          <form class="contact-form">
            <label class="contact-label" for="contact-name">お名前</label>
            <input class="contact-input" type="text" id="contact-name" name="name" placeholder="Tomohisa Sasaki" required>

            <label class="contact-label" for="contact-email">メールアドレス</label>
            <input class="contact-input" type="email" id="contact-email" name="email" placeholder="name@example.com" required>

            <label class="contact-label" for="contact-message">メッセージ</label>
            <textarea class="contact-input contact-input--textarea" id="contact-message" name="message" rows="5" placeholder="コラボや質問など、お気軽にどうぞ"></textarea>

            <button type="submit" class="contact-submit">送信</button>
          </form>
        </div>
      </section>
    </main>
  </div>

  <script>
    (function () {
      const navButtons = document.querySelectorAll('[data-nav-target]');
      const sections = [];
      navButtons.forEach((button) => {
        const targetSelector = button.dataset.navTarget;
        const targetSection = document.querySelector(targetSelector);
        if (!targetSection) {
          return;
        }
        sections.push({ button, target: targetSection });
        button.addEventListener('click', () => {
          targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
      });

      if (!sections.length) {
        return;
      }

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              sections.forEach(({ button, target }) => {
                if (target === entry.target) {
                  button.classList.add('is-active');
                } else {
                  button.classList.remove('is-active');
                }
              });
            }
          });
        },
        {
          root: null,
          threshold: 0.4
        }
      );

      sections.forEach(({ target }) => observer.observe(target));
    })();

    (function () {
      const revealTargets = document.querySelectorAll('[data-motion]');
      if (!('IntersectionObserver' in window) || !revealTargets.length) {
        revealTargets.forEach((el) => el.classList.add('is-visible'));
        return;
      }
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add('is-visible');
              observer.unobserve(entry.target);
            }
          });
        },
        { threshold: 0.2, rootMargin: '0px 0px -10% 0px' }
      );
      revealTargets.forEach((el, index) => {
        el.style.setProperty('--motion-index', index);
        observer.observe(el);
      });
    })();

    (function () {
      const trainer = document.querySelector('[data-trainer]');
      if (!trainer) {
        return;
      }

      const focusLabels = {
        chest: 'Chest',
        shoulders: 'Shoulders',
        arms: 'Arms',
        legs: 'Legs',
        back: 'Back'
      };

      const focusBadges = {
        chest: 'CH',
        shoulders: 'SH',
        arms: 'AR',
        legs: 'LG',
        back: 'BK'
      };

      const movementLibrary = {
        chest: ['Flat Bench Press', 'Incline Dumbbell Press', 'Cable Fly', 'Push-Up Variations'],
        shoulders: ['Seated Dumbbell Press', 'Lateral Raise', 'Rear Delt Fly', 'Face Pull'],
        arms: ['Barbell Curl', 'Hammer Curl', 'Triceps Dip', 'Skull Crusher'],
        legs: ['Back Squat', 'Romanian Deadlift', 'Bulgarian Split Squat', 'Leg Press'],
        back: ['Deadlift', 'Bent-Over Row', 'Lat Pulldown', 'Single-Arm Row']
      };

      const metricLabels = {
        volume: 'Volume (sets×reps×weight)',
        reps: 'Total reps',
        weight: 'Average weight'
      };

      const dateInput = trainer.querySelector('[data-trainer-date]');
      const focusSelect = trainer.querySelector('[data-trainer-focus]');
      const movementSelect = trainer.querySelector('[data-trainer-movement]');
      const setsInput = trainer.querySelector('[data-trainer-sets]');
      const repsInput = trainer.querySelector('[data-trainer-reps]');
      const weightInput = trainer.querySelector('[data-trainer-weight]');
      const notesInput = trainer.querySelector('[data-trainer-notes]');
      const addButton = trainer.querySelector('[data-trainer-add]');
      const saveButton = trainer.querySelector('[data-trainer-save]');
      const clearButton = trainer.querySelector('[data-trainer-clear]');
      const logList = trainer.querySelector('[data-trainer-log]');
      const logEmpty = trainer.querySelector('[data-trainer-log-empty]');
      const calendarGrid = trainer.querySelector('[data-trainer-calendar]');
      const calendarTitle = trainer.querySelector('[data-trainer-calendar-title]');
      const periodEl = trainer.querySelector('[data-trainer-period]');
      const filterMovementSelect = trainer.querySelector('[data-trainer-filter-movement]');
      const filterMetricSelect = trainer.querySelector('[data-trainer-filter-metric]');
      const chartContainer = trainer.querySelector('[data-trainer-chart]');
      const trendSubtitleEl = trainer.querySelector('[data-trainer-trend-subtitle]');
      const totalSetsEl = trainer.querySelector('[data-trainer-total-sets]');
      const totalLoadEl = trainer.querySelector('[data-trainer-total-load]');
      const focusMixEl = trainer.querySelector('[data-trainer-focus-mix]');
      const statusEl = trainer.querySelector('[data-trainer-status]');
      const monthButtons = trainer.querySelectorAll('[data-trainer-month]');

      if (
        !dateInput ||
        !focusSelect ||
        !movementSelect ||
        !setsInput ||
        !repsInput ||
        !weightInput ||
        !notesInput ||
        !addButton ||
        !saveButton ||
        !clearButton ||
        !logList ||
        !logEmpty ||
        !calendarGrid ||
        !calendarTitle ||
        !periodEl ||
        !filterMovementSelect ||
        !filterMetricSelect ||
        !chartContainer ||
        !trendSubtitleEl ||
        !totalSetsEl ||
        !totalLoadEl ||
        !focusMixEl ||
        !statusEl
      ) {
        return;
      }

      let statusTimeout = null;
      const today = new Date();

      const state = {
        entries: new Map(),
        draft: [],
        selectedDate: formatISO(today),
        monthCursor: new Date(today.getFullYear(), today.getMonth(), 1)
      };

      dateInput.value = state.selectedDate;

      const formatters = {
        month: new Intl.DateTimeFormat('ja-JP', { month: 'long', year: 'numeric' })
      };

      function formatISO(date) {
        return date.toISOString().slice(0, 10);
      }

      function parseISO(iso) {
        const [y, m, d] = iso.split('-').map(Number);
        return new Date(y, m - 1, d);
      }

      function setStatus(message, tone = 'neutral') {
        statusEl.textContent = message;
        statusEl.setAttribute('data-tone', tone);
        if (statusTimeout) {
          clearTimeout(statusTimeout);
        }
        statusTimeout = window.setTimeout(() => {
          statusEl.textContent = 'Session idle';
          statusEl.setAttribute('data-tone', 'neutral');
        }, 3200);
      }

      function setMovementOptions(focus) {
        const movements = movementLibrary[focus] || [];
        movementSelect.innerHTML = '';
        movements.forEach((movement, index) => {
          const option = document.createElement('option');
          option.value = movement;
          option.textContent = movement;
          if (index === 0) {
            option.selected = true;
          }
          movementSelect.append(option);
        });
      }

      function getSavedEntriesFor(dateISO) {
        return state.entries.get(dateISO) || [];
      }

      function getAllSavedEntries() {
        const collection = [];
        state.entries.forEach((entries, iso) => {
          entries.forEach((entry) => collection.push({ iso, ...entry }));
        });
        return collection;
      }

      function populateMovementFilter() {
        const previous = filterMovementSelect.value || 'all';
        const movements = new Set();
        getAllSavedEntries().forEach((entry) => movements.add(entry.movement));
        const sorted = Array.from(movements).sort((a, b) => a.localeCompare(b));
        filterMovementSelect.innerHTML = '';
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = 'All Movements';
        filterMovementSelect.append(allOption);
        sorted.forEach((movement) => {
          const option = document.createElement('option');
          option.value = movement;
          option.textContent = movement;
          filterMovementSelect.append(option);
        });
        if (previous !== 'all' && !movements.has(previous)) {
          filterMovementSelect.value = 'all';
        } else {
          filterMovementSelect.value = previous;
        }
      }

      function renderLog() {
        logList.innerHTML = '';
        const saved = getSavedEntriesFor(state.selectedDate);
        const pending = state.draft;
        if (!saved.length && !pending.length) {
          logEmpty.hidden = false;
          return;
        }
        logEmpty.hidden = true;
        const fragment = document.createDocumentFragment();
        const appendEntry = (entry, statusLabel) => {
          const item = document.createElement('li');
          item.className = 'trainer-log__item';
          item.innerHTML = `
            <div class="trainer-log__meta">
              <span>${statusLabel}</span>
              <span>${focusLabels[entry.focus]}</span>
              <span>${entry.sets}×${entry.reps} @ ${entry.weight}kg</span>
            </div>
            <p class="trainer-log__title">${entry.movement}</p>
            <p class="trainer-log__notes">${entry.notes ? entry.notes : 'No notes provided.'}</p>
          `;
          fragment.append(item);
        };
        saved.forEach((entry) => appendEntry(entry, 'Saved'));
        pending.forEach((entry) => appendEntry(entry, 'Pending'));
        logList.append(fragment);
      }

      function renderCalendar() {
        calendarGrid.innerHTML = '';
        const year = state.monthCursor.getFullYear();
        const month = state.monthCursor.getMonth();
        const firstOfMonth = new Date(year, month, 1);
        const startingDay = firstOfMonth.getDay();
        const startDate = new Date(year, month, 1 - startingDay);
        const totalCells = 42;
        calendarTitle.textContent = formatters.month.format(firstOfMonth);
        for (let i = 0; i < totalCells; i++) {
          const current = new Date(startDate);
          current.setDate(startDate.getDate() + i);
          const iso = formatISO(current);
          const dayButton = document.createElement('button');
          dayButton.type = 'button';
          dayButton.className = 'trainer-day';
          dayButton.textContent = current.getDate().toString();
          if (current.getMonth() !== month) {
            dayButton.classList.add('is-other');
          }
          if (iso === state.selectedDate) {
            dayButton.classList.add('is-selected');
          }
          const saved = getSavedEntriesFor(iso);
          if (saved.length) {
            dayButton.dataset.hasSession = 'true';
            const focusCount = saved.reduce((acc, entry) => {
              acc[entry.focus] = (acc[entry.focus] || 0) + 1;
              return acc;
            }, {});
            const dominant = Object.entries(focusCount).sort((a, b) => b[1] - a[1])[0][0];
            dayButton.dataset.focus = dominant;
            const badge = document.createElement('span');
            badge.className = 'trainer-day__badge';
            badge.textContent = focusBadges[dominant] || dominant.toUpperCase();
            dayButton.append(badge);
          }
          dayButton.addEventListener('click', () => {
            state.selectedDate = iso;
            state.draft = [];
            dateInput.value = iso;
            setStatus(`${iso} をロードしました`, 'neutral');
            renderAll();
          });
          calendarGrid.append(dayButton);
        }
      }

      function renderChart() {
        chartContainer.innerHTML = '';
        const metric = filterMetricSelect.value;
        const movement = filterMovementSelect.value;
        const entries = getAllSavedEntries().filter((entry) => movement === 'all' || entry.movement === movement);
        if (!entries.length) {
          const empty = document.createElement('p');
          empty.className = 'trainer-chart__empty';
          empty.textContent = 'ログが足りません';
          chartContainer.append(empty);
          return;
        }
        const grouped = entries.reduce((acc, entry) => {
          acc[entry.iso] = acc[entry.iso] || [];
          acc[entry.iso].push(entry);
          return acc;
        }, {});
        const points = Object.entries(grouped)
          .map(([date, items]) => {
            const value = items.reduce((total, item) => {
              if (metric === 'volume') {
                return total + item.sets * item.reps * item.weight;
              }
              if (metric === 'reps') {
                return total + item.sets * item.reps;
              }
              return total + item.weight;
            }, 0);
            return { date, value: metric === 'weight' ? value / items.length : value };
          })
          .sort((a, b) => a.date.localeCompare(b.date));
        trendSubtitleEl.textContent = metricLabels[metric];
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        const width = 320;
        const height = 160;
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('role', 'img');
        svg.setAttribute('aria-label', 'Training trend chart');
        const maxVal = Math.max(...points.map((point) => point.value));
        const minVal = Math.min(...points.map((point) => point.value));
        const range = maxVal - minVal || 1;
        const pathData = points
          .map((point, index) => {
            const x = (index / (points.length - 1 || 1)) * (width - 20) + 10;
            const y = height - ((point.value - minVal) / range) * (height - 20) - 10;
            return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
          })
          .join(' ');
        const path = document.createElementNS(svgNS, 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#a868ff');
        path.setAttribute('stroke-width', '2.5');
        path.setAttribute('stroke-linecap', 'round');
        svg.append(path);
        points.forEach((point, index) => {
          const x = (index / (points.length - 1 || 1)) * (width - 20) + 10;
          const y = height - ((point.value - minVal) / range) * (height - 20) - 10;
          const circle = document.createElementNS(svgNS, 'circle');
          circle.setAttribute('cx', x);
          circle.setAttribute('cy', y);
          circle.setAttribute('r', '4');
          circle.setAttribute('fill', '#7a8cff');
          svg.append(circle);
        });
        chartContainer.append(svg);
      }

      function renderSummary() {
        let totalSets = 0;
        let totalLoad = 0;
        const focusCounter = {};
        state.entries.forEach((entries) => {
          entries.forEach((entry) => {
            totalSets += entry.sets;
            totalLoad += entry.sets * entry.reps * entry.weight;
            focusCounter[entry.focus] = (focusCounter[entry.focus] || 0) + 1;
          });
        });
        totalSetsEl.textContent = totalSets;
        totalLoadEl.textContent = `${Math.round(totalLoad)} kg`;
        if (!Object.keys(focusCounter).length) {
          focusMixEl.textContent = '—';
          return;
        }
        focusMixEl.textContent = Object.entries(focusCounter)
          .sort((a, b) => b[1] - a[1])
          .map(([focus, count]) => `${focusLabels[focus]} (${count})`)
          .join(' · ');
      }

      function renderPeriod() {
        const selected = parseISO(state.selectedDate);
        const start = new Date(selected);
        const day = selected.getDay();
        const diffToMonday = (day + 6) % 7;
        start.setDate(selected.getDate() - diffToMonday);
        const end = new Date(start);
        end.setDate(start.getDate() + 6);
        const formatter = new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric' });
        periodEl.textContent = `${formatter.format(start)} – ${formatter.format(end)}`;
      }

      function renderAll() {
        renderLog();
        renderCalendar();
        populateMovementFilter();
        renderChart();
        renderSummary();
        renderPeriod();
      }

      function addEntry() {
        const movement = movementSelect.value;
        if (!movement) {
          setStatus('ムーブメントを選択してください', 'warn');
          return;
        }
        const focus = focusSelect.value;
        const sets = Number(setsInput.value) || 1;
        const reps = Number(repsInput.value) || 1;
        const weight = Number(weightInput.value) || 0;
        const notes = notesInput.value.trim();
        state.draft.push({
          date: state.selectedDate,
          focus,
          movement,
          sets,
          reps,
          weight,
          notes
        });
        notesInput.value = '';
        setStatus(`${movement} を追加`, 'success');
        renderLog();
      }

      function commitDay() {
        if (!state.draft.length) {
          setStatus('ムーブメントを追加してください', 'warn');
          return;
        }
        const current = getSavedEntriesFor(state.selectedDate);
        state.entries.set(state.selectedDate, [...current, ...state.draft]);
        state.draft = [];
        setStatus(`${state.selectedDate} を保存`, 'success');
        renderAll();
      }

      function clearComposer() {
        state.draft = [];
        notesInput.value = '';
        setsInput.value = '3';
        repsInput.value = '8';
        weightInput.value = '60';
        setMovementOptions(focusSelect.value);
        renderLog();
        setStatus('リセット完了', 'neutral');
      }

      function shiftMonth(direction) {
        const delta = direction === 'next' ? 1 : -1;
        state.monthCursor.setMonth(state.monthCursor.getMonth() + delta);
        renderCalendar();
      }

      focusSelect.addEventListener('change', () => setMovementOptions(focusSelect.value));
      dateInput.addEventListener('change', () => {
        const next = dateInput.value || formatISO(new Date());
        state.selectedDate = next;
        state.draft = [];
        state.monthCursor = new Date(Number(next.slice(0, 4)), Number(next.slice(5, 7)) - 1, 1);
        renderAll();
      });
      addButton.addEventListener('click', addEntry);
      saveButton.addEventListener('click', commitDay);
      clearButton.addEventListener('click', clearComposer);
      monthButtons.forEach((button) => {
        button.addEventListener('click', () => shiftMonth(button.dataset.trainerMonth));
      });
      filterMovementSelect.addEventListener('change', renderChart);
      filterMetricSelect.addEventListener('change', renderChart);

      setMovementOptions(focusSelect.value);
      renderAll();
    })();
  </script>
</body>
</html>
